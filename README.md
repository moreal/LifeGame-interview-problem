# 인터뷰 문제 예상

**자신있게** (틀려도 마지막에 궁금한 거 물어보라할때 어떤 건가요? 제가 어땠었나요)

## 인간적인

- 회사에 지원한 이유
- 자기소개
- 자신이 생각하는 게임이란게
- 게임을 만들때에 있어서 자신이 중요하게 생각하는 것은?
  완성도 입니다
- 취미가 무엇인가요  
  음악을 듣거나 게임을 하거나


- 영어를 어느정도 할 줄 아나요  
  도큐먼트를 읽고 ReadMe를 작성하고 사전과 함께 번역할 정도는 됩니다.
  물론 전공 쪽에 한정하기는 합니다.

- GCP의 장점은 무엇인가요?
- Couchbase의 장점은 무엇인가요?
- 왜 도커를 선택하였나요?
- 도커의 장점과 단점은 무엇인가요
- WSGI란 무엇인가요
- Ruby란 무엇인가요
- Ruby의 장점은 무엇인가요
- UnrealEngine으로 어떤 것을 구현했나요 (red-ticket)
- Slack을 왜 사용하나요 (장점)
- Travis-CI를 사용한 이유는? (CI를 사용한 이유는?)
- 왜 Boost를 사용하였나요  
  서버 제작을 위한 기반작업에 시간을 들이기 보다는 그 위의 코드의 구조에 더 신경을 쓰고 싶었습니다.  
  이미 나와있는 라이브러리를 사용함으로써 안정성 부분에서 이득을 취하고 싶었습니다.

- 왜 Python을 사용하나요?  
  스크립트 언어이고 정말 많은 스크립트를 사용합니다. 빠르게 쉘에서 돌릴 수 있었고 빠르게 짜고 빠르게 돌려볼 수 있었습니다.

- 왜 Go를 공부했나요?  
  본래 Go를 공부하게 된 계기는
- 프로젝트가 주어졌는데 아무도 해본적이 없는 분야다. 어떻게 할 것인가?

## 기술적인

### 운영체제

- 프로세스와 쓰레드의 차이
  
  프로세스는 운영체제로 부터 물리적인 메모리, CPU등을 할당 받는 객체, 주체이다.
  프로세스들 끼리는 파이프 통신등의 과정 없이는 서로의 영역, 공간에 접근 할 수 없다.

  그에 비해 쓰레드는 다른 스레드들과 코드, 데이터와 같은 메모리 공간을 공유한다.
  단점은 프로세스 하나가 블로킹되면 그 안에 있는 스레드 전체가 블로킹된다.

  +) 코루틴은 흐름을 유지하면서로 함수의 흐름을 바꿀 수 있다. 프로세스나 스레드가 자신을 스케줄링하는 객체가 있다면 코루틴은 스스로 실행타임을 돌려주고 다시 원래의 흐름으로 진입할 수 있다

- Context Switching 이란
  
  프로세스나 스레드에서 다른 프로세스로 이동하는 과정입니다. 자신의 레지스터 정보등을 PCB에 저장해 놓고 CPU 권한을 다른 프로세스에게 넘기게 됩니다.

- 사용자 수준 쓰레드와 커널 수준 쓰레드의 차이
- 페이지와 세그먼테이션

### 자료구조

- Stack vs Queue
  둘다 선형구조의 자료형이다. LIFO 와 FIFO의 차이를 가지고 있다. 구현법은 비슷하다.

- Queue 두개로 Stack을 만들어 보세요  
  length - 1 만큼 팝하여 다른 큐에 push하고 마지막 하나를 팝의 결과로 리턴한다. 이런 과정을 반복하면 Stack 처럼 사용 가능하다.

- Heap

- 레드블랙트리

### 알고리즘

- QuickSort  
  분할정복, 퀵소트는 빠르지 않다. 정렬해야 될 구간을 분할하면서 계속 바꾸면서 사용하다보니 CPU의 캐시 히트를 맞추는 것도 어렵고 이는 속도 저하의 요소가 된다. 그러므로 메모리가 충분하다면 삽입정렬이나 병합정렬을 통해서 사용할 것이다.

- Insertion sort  
  데이터를 삽입하는 과정에서 정렬을 하는 방식이다.

  만약 이미 입력이 모두 되어 있는 상황에서 이 정렬을 하고자 한다면 기존의 데이터를 만큼의 새로운 정렬 상태가 필요할 것이다. 

- merge sort  
  계속 분할하여 다시 병합하면서 정렬하는 방식이다. Python으로 작성하면 정말 빠르게 가능하지만 C++같이 직접 메모리 할당해주고 정리해줘야 하는 경우 조금은 번거로울 수 있다. 파편화가 걱정되기도 한다. 
### 데이터베이스
- RDB (관계형 데이터베이스)
  
  ACID라는 개념을 위해 트랜잭션이 존재한다.
- 트랜잭션 단계
- NoSQL이란
  
  Not Only SQL 이라고 많이 부르는 것 같습니다.
  큰 데이터를 저장하고 동적 스키마를 지원하고 빅데이터, 분산시스템에 적합하게 되어 있습니다.

  SQL의 경우에는 동적으로 스키마를 바꾸기가 어려웠고 이에 따라 스키마리스, 다이내믹한 NoSQL이 있습니다.

  종류에는 Document(MongoDB, Couchbase), Graph(?), Column Family(BigTable), Key-Value(Redis, in-memory)

- CAP  
  일관성  
  언제 어디서 접근하던지 동일한 결과를 반영해야 한다  
  
  가용성  
  항상 접근이 가능해야한다.

  파티션  
  만약 A지점의 데이터 센터가 장애가 생겼을 경우에 B지점의 데이터 센터, 접근은 가능해야 한다.

  동시에 모든 것을 만족 시킬 수는 없다.

### About My Interests

#### Distributed server architecture and NoSQL for high availability

- 
#### Multi-threading(processing) programming

- 뮤텍스
- 세마포어
- 스핀락
- 데이터 레이스

#### How to make clean(good) code



#### Open source and community activity

- Docker, PyCharm 번역 (이거 다시 해야겠다)


